# Fedify Comprehensive Reference

This reference provides detailed documentation for building and maintaining ActivityPub applications with Fedify.

## Table of Contents

1. [Federation Configuration](#federation-configuration)
2. [Actor System](#actor-system)
3. [Activity Vocabulary](#activity-vocabulary)
4. [Inbox Handling](#inbox-handling)
5. [Sending Activities](#sending-activities)
6. [Collections](#collections)
7. [Object Dispatchers](#object-dispatchers)
8. [Access Control](#access-control)
9. [Context Object](#context-object)
10. [Testing](#testing)
11. [Logging & Observability](#logging--observability)
12. [Framework Integration](#framework-integration)
13. [Production Deployment](#production-deployment)
14. [FEP Reference](#fep-reference)

---

## Federation Configuration

### Creating a Federation Instance

```typescript
import {
  createFederation,
  MemoryKvStore,
  InProcessMessageQueue,
} from "@fedify/fedify";

const federation = createFederation<ContextData>({
  // Required: Key-value store for cache and state
  kv: new MemoryKvStore(),

  // Recommended: Message queue for async activity processing
  queue: new InProcessMessageQueue(),

  // Optional: Separate web and queue workers
  manuallyStartQueue: false,

  // Optional: Explicit origin (for reverse proxies)
  origin: "https://example.com",

  // Optional: Allow private addresses (testing only - SSRF risk)
  allowPrivateAddress: false,
});
```

### Key-Value Store Options

| Store | Package | Use Case |
|-------|---------|----------|
| `MemoryKvStore` | `@fedify/fedify` | Development only |
| `DenoKvStore` | `@fedify/fedify` | Deno Deploy |
| Redis | `@fedify/redis` | Production |
| PostgreSQL | `@fedify/postgres` | Production |

### Message Queue Options

| Queue | Package | Use Case |
|-------|---------|----------|
| `InProcessMessageQueue` | `@fedify/fedify` | Development |
| `DenoKvMessageQueue` | `@fedify/fedify` | Deno Deploy |
| Redis | `@fedify/redis` | Production |
| PostgreSQL | `@fedify/postgres` | Production |
| RabbitMQ/AMQP | `@fedify/amqp` | Production |

### Builder Pattern (Large Applications)

For applications with circular dependencies:

```typescript
import { createFederationBuilder } from "@fedify/fedify";

const builder = createFederationBuilder<ContextData>();

// Configure dispatchers
builder.setActorDispatcher("/users/{identifier}", actorHandler);
builder.setInboxListeners("/users/{identifier}/inbox", "/inbox");

// Build when ready
const federation = await builder.build({
  kv: new MemoryKvStore(),
});
```

---

## Actor System

### Actor Dispatcher

The actor dispatcher is the most critical component - it maps identifiers to actors:

```typescript
federation.setActorDispatcher("/users/{identifier}", async (ctx, identifier) => {
  const user = await db.getUserById(identifier);
  if (!user) return null;

  const keyPairs = await ctx.getActorKeyPairs(identifier);

  return new Person({
    // Required
    id: ctx.getActorUri(identifier),

    // Identity
    preferredUsername: user.username,
    name: user.displayName,
    summary: user.bio,
    url: new URL(`/@${user.username}`, ctx.origin),

    // Avatar/Header
    icon: new Image({ url: new URL(user.avatarUrl) }),
    image: new Image({ url: new URL(user.headerUrl) }),

    // Endpoints (auto-generated by Fedify)
    inbox: ctx.getInboxUri(identifier),
    outbox: ctx.getOutboxUri(identifier),
    followers: ctx.getFollowersUri(identifier),
    following: ctx.getFollowingUri(identifier),

    // Cryptographic keys
    publicKey: keyPairs[0].cryptographicKey,
    assertionMethods: keyPairs.map(kp => kp.multikey),

    // Timestamps
    published: Temporal.Instant.from(user.createdAt),
  });
});
```

### Supported Actor Types

- `Person` - Individual users
- `Application` - Bots, automated accounts
- `Group` - Groups/communities
- `Organization` - Organizations
- `Service` - Service accounts

### Key Pairs Dispatcher

Required for sending signed activities:

```typescript
import { importJwk, exportJwk, generateCryptoKeyPair } from "@fedify/fedify";

federation.setKeyPairsDispatcher(async (ctx, identifier) => {
  const user = await db.getUserById(identifier);

  // Load existing keys from database
  const rsaKeyPair = {
    publicKey: await importJwk(JSON.parse(user.rsaPublicKeyJwk), "public"),
    privateKey: await importJwk(JSON.parse(user.rsaPrivateKeyJwk), "private"),
  };

  // Ed25519 for Object Integrity Proofs (optional but recommended)
  const ed25519KeyPair = {
    publicKey: await importJwk(JSON.parse(user.ed25519PublicKeyJwk), "public"),
    privateKey: await importJwk(JSON.parse(user.ed25519PrivateKeyJwk), "private"),
  };

  return [rsaKeyPair, ed25519KeyPair];
});

// Generate keys during user registration
async function createUserKeys() {
  const rsaKeyPair = await generateCryptoKeyPair("RSASSA-PKCS1-v1_5");
  const ed25519KeyPair = await generateCryptoKeyPair("Ed25519");

  return {
    rsaPublicKeyJwk: JSON.stringify(await exportJwk(rsaKeyPair.publicKey)),
    rsaPrivateKeyJwk: JSON.stringify(await exportJwk(rsaKeyPair.privateKey)),
    ed25519PublicKeyJwk: JSON.stringify(await exportJwk(ed25519KeyPair.publicKey)),
    ed25519PrivateKeyJwk: JSON.stringify(await exportJwk(ed25519KeyPair.privateKey)),
  };
}
```

### Handle Mapping (Username Decoupling)

Allow username changes without breaking federation:

```typescript
federation.mapHandle(async (ctx, username) => {
  const user = await db.getUserByUsername(username);
  return user?.id;  // Return internal identifier
});
```

### Actor Aliases

Map multiple URLs to the same actor:

```typescript
federation.mapAlias(async (ctx, aliasUrl) => {
  // e.g., map /@username to /users/{id}
  const match = aliasUrl.pathname.match(/^\/@(\w+)$/);
  if (match) {
    const user = await db.getUserByUsername(match[1]);
    return user?.id;
  }
  return null;
});
```

---

## Activity Vocabulary

### Importing Types

```typescript
import {
  // Actors
  Person, Application, Group, Organization, Service,

  // Objects
  Note, Article, Image, Video, Audio, Document, Page,
  Object as ASObject,  // Alias to avoid JS conflict

  // Activities
  Create, Update, Delete,
  Follow, Accept, Reject,
  Like, Announce,  // Announce = Boost/Share
  Undo,
  Add, Remove,
  Block, Flag,

  // Collections
  Collection, OrderedCollection,
  CollectionPage, OrderedCollectionPage,
} from "@fedify/fedify";
```

### Creating Objects

Objects are immutable and created with constructors:

```typescript
const note = new Note({
  id: new URL("https://example.com/notes/123"),
  attributedTo: new URL("https://example.com/users/alice"),
  content: "<p>Hello, fediverse!</p>",
  summary: "Content warning text",  // CW/spoiler
  published: Temporal.Now.instant(),
  updated: Temporal.Now.instant(),
  sensitive: false,

  // Addressing
  to: new URL("https://www.w3.org/ns/activitystreams#Public"),
  cc: [
    new URL("https://example.com/users/alice/followers"),
    new URL("https://remote.example/users/bob"),
  ],

  // Attachments
  attachment: [
    new Image({ url: new URL("https://example.com/image.jpg") }),
  ],

  // Reply
  inReplyTo: new URL("https://remote.example/notes/456"),

  // Tags/Mentions
  tag: [
    new Mention({
      href: new URL("https://remote.example/users/bob"),
      name: "@bob@remote.example",
    }),
    new Hashtag({
      href: new URL("https://example.com/tags/fedify"),
      name: "#fedify",
    }),
  ],
});
```

### Modifying Objects (Clone)

```typescript
const updatedNote = note.clone({
  content: "<p>Updated content</p>",
  updated: Temporal.Now.instant(),
});
```

### JSON-LD Serialization

```typescript
// To JSON-LD
const jsonLd = await note.toJsonLd();

// From JSON-LD
const restored = await Note.fromJsonLd(jsonLd);
```

### Property Access Patterns

| Property Type | Single Value | Multiple Values | Lazy Load |
|---------------|--------------|-----------------|-----------|
| Scalar | `.published` | `.names` | N/A |
| Non-scalar | `.actorId` | `.actorIds` | `.getActor()` / `.getActors()` |

```typescript
// Direct access (returns URL)
const actorUri = activity.actorId;

// Lazy load (fetches remote object)
const actor = await activity.getActor();
```

---

## Inbox Handling

### Setting Up Inbox Listeners

```typescript
federation
  .setInboxListeners(
    "/users/{identifier}/inbox",  // Personal inbox
    "/inbox"                       // Shared inbox (optional)
  )
  .on(Follow, handleFollow)
  .on(Accept, handleAccept)
  .on(Reject, handleReject)
  .on(Create, handleCreate)
  .on(Update, handleUpdate)
  .on(Delete, handleDelete)
  .on(Like, handleLike)
  .on(Announce, handleAnnounce)
  .on(Undo, handleUndo)
  .on(Block, handleBlock)
  .onError(handleError);
```

### Handler Examples

```typescript
// Follow handler
async function handleFollow(ctx: InboxContext, follow: Follow) {
  const follower = await follow.getActor();
  const followeeId = ctx.recipient;  // null for shared inbox

  if (!followeeId) {
    // Parse from to/cc fields for shared inbox
    return;
  }

  // Store follow request
  await db.createFollowRequest(follower.id!.href, followeeId);

  // Auto-accept (or implement manual approval)
  await ctx.sendActivity(
    { identifier: followeeId },
    follower,
    new Accept({
      id: new URL(`urn:uuid:${crypto.randomUUID()}`),
      actor: ctx.getActorUri(followeeId),
      object: follow,
    })
  );
}

// Create handler (new posts)
async function handleCreate(ctx: InboxContext, create: Create) {
  const object = await create.getObject();

  if (object instanceof Note) {
    const author = await create.getActor();
    await db.createRemotePost({
      uri: object.id!.href,
      authorUri: author.id!.href,
      content: object.content?.toString() ?? "",
      published: object.published?.toString(),
    });
  }
}

// Undo handler
async function handleUndo(ctx: InboxContext, undo: Undo) {
  const object = await undo.getObject();
  const actor = await undo.getActor();

  if (object instanceof Follow) {
    await db.removeFollow(actor.id!.href, ctx.recipient);
  } else if (object instanceof Like) {
    await db.removeLike(actor.id!.href, object.objectId!.href);
  } else if (object instanceof Announce) {
    await db.removeBoost(actor.id!.href, object.objectId!.href);
  }
}

// Error handler
async function handleError(error: Error, activity: Activity) {
  console.error("Inbox error:", error, activity);
}
```

### Activity Idempotency

Configure deduplication strategy:

```typescript
federation.setInboxListeners("/users/{identifier}/inbox", "/inbox", {
  // "per-inbox" (default), "per-origin", or "global"
  activityIdempotency: "per-inbox",
});
```

### Activity Forwarding

Forward activities while preserving signatures:

```typescript
.on(Create, async (ctx, create) => {
  // Forward to group members
  await ctx.forwardActivity(create, groupMemberInboxes);
});
```

---

## Sending Activities

### Basic Sending

```typescript
await ctx.sendActivity(
  // Sender: identifier, username, or key pairs
  { identifier: "alice" },

  // Recipients: Actor, Actor[], Recipient[], or "followers"
  recipient,

  // Activity
  new Create({
    actor: ctx.getActorUri("alice"),
    object: note,
  }),

  // Options (optional)
  {
    preferSharedInbox: true,
    immediate: false,
    excludeBaseUris: [ctx.origin],
  }
);
```

### Sending to Followers

```typescript
// Requires followers collection dispatcher
await ctx.sendActivity(
  { identifier: "alice" },
  "followers",
  new Create({ actor: ctx.getActorUri("alice"), object: note })
);
```

### Delivery Options

```typescript
{
  // Use shared inbox when available
  preferSharedInbox: true,

  // Bypass queue (not recommended for production)
  immediate: false,

  // Skip local delivery
  excludeBaseUris: [new URL("https://example.com")],

  // Followers sync (for "followers" recipient)
  syncCollection: true,
}
```

### Error Handling

```typescript
const federation = createFederation({
  // ...
  onOutboxError: (error, activity) => {
    console.error("Delivery failed:", error, activity.id);
  },
});
```

---

## Collections

### Followers Collection

```typescript
federation.setFollowersDispatcher(
  "/users/{identifier}/followers",
  async (ctx, identifier, cursor) => {
    if (cursor == null) return null;  // Return full collection if no pagination

    const offset = cursor === "" ? 0 : parseInt(cursor);
    const limit = 20;

    const followers = await db.getFollowers(identifier, offset, limit);

    return {
      items: followers.map(f => new URL(f.actorUri)),
      nextCursor: followers.length === limit ? String(offset + limit) : null,
    };
  }
)
.setFirstCursor(async (ctx, identifier) => "")
.setLastCursor(async (ctx, identifier) => {
  const count = await db.countFollowers(identifier);
  return String(Math.max(0, count - 20));
})
.setCounter(async (ctx, identifier) => db.countFollowers(identifier));
```

### Following Collection

```typescript
federation.setFollowingDispatcher(
  "/users/{identifier}/following",
  async (ctx, identifier, cursor) => {
    // Similar pattern to followers
  }
);
```

### Outbox Collection

```typescript
federation.setOutboxDispatcher(
  "/users/{identifier}/outbox",
  async (ctx, identifier, cursor) => {
    if (cursor == null) return null;

    const posts = await db.getPosts(identifier, cursor);

    const items = posts.map(post =>
      new Create({
        id: new URL(`/posts/${post.id}#activity`, ctx.origin),
        actor: ctx.getActorUri(identifier),
        published: Temporal.Instant.from(post.createdAt),
        object: new Note({
          id: ctx.getObjectUri(Note, { id: post.id }),
          content: post.content,
        }),
      })
    );

    return { items, nextCursor: posts.nextCursor };
  }
);
```

### Custom Collections

```typescript
federation.setCollectionDispatcher(
  "bookmarks",      // Collection name
  Article,          // Item type
  "/users/{identifier}/bookmarks",
  async (ctx, values, cursor) => {
    const bookmarks = await db.getBookmarks(values.identifier, cursor);
    return {
      items: bookmarks.map(b => new Article({ /* ... */ })),
      nextCursor: bookmarks.nextCursor,
    };
  }
)
.setFirstCursor(async () => "");
```

---

## Object Dispatchers

Expose objects for remote fetching:

```typescript
// Notes/Posts
federation.setObjectDispatcher(
  Note,
  "/posts/{id}",
  async (ctx, { id }) => {
    const post = await db.getPost(id);
    if (!post) return null;

    return new Note({
      id: ctx.getObjectUri(Note, { id }),
      attributedTo: ctx.getActorUri(post.authorId),
      content: post.content,
      published: Temporal.Instant.from(post.createdAt),
      to: new URL("https://www.w3.org/ns/activitystreams#Public"),
    });
  }
);

// Generate URI for objects
const noteUri = ctx.getObjectUri(Note, { id: "123" });
```

---

## Access Control

### Authorized Fetch (HTTP Signature Verification)

```typescript
federation.setActorDispatcher("/users/{identifier}", handler)
  .authorize(async (ctx, identifier, signedKey, signedKeyOwner) => {
    // signedKey: CryptographicKey used to sign request
    // signedKeyOwner: Actor who owns the key

    if (signedKeyOwner == null) {
      return false;  // Reject unsigned requests
    }

    // Allow all signed requests
    return true;

    // Or check specific conditions
    // return !await db.isBlocked(signedKeyOwner.id!.href, identifier);
  });
```

### Fine-Grained Access Control

```typescript
federation.setFollowersDispatcher("/users/{identifier}/followers",
  async (ctx, identifier, cursor) => {
    const signedKeyOwner = await ctx.getSignedKeyOwner();

    if (signedKeyOwner == null) {
      // Return public subset only
      return { items: [] };
    }

    // Return full list for authenticated requests
    const followers = await db.getFollowers(identifier);
    return { items: followers };
  }
);
```

### Instance Actor

Prevent authentication loops:

```typescript
federation.setActorDispatcher("/users/{identifier}", async (ctx, identifier) => {
  if (identifier === ctx.hostname) {
    // Instance actor
    return new Application({
      id: ctx.getActorUri(identifier),
      preferredUsername: ctx.hostname,
      inbox: ctx.getInboxUri(identifier),
      publicKey: (await ctx.getActorKeyPairs(identifier))[0].cryptographicKey,
    });
  }
  // Regular user
});
```

---

## Context Object

### Key Properties

| Property | Description |
|----------|-------------|
| `ctx.hostname` | Domain name |
| `ctx.host` | Domain with port |
| `ctx.origin` | Scheme + host |
| `ctx.url` | Full request URL |

### URI Generation Methods

```typescript
ctx.getActorUri(identifier)
ctx.getInboxUri(identifier)
ctx.getOutboxUri(identifier)
ctx.getFollowersUri(identifier)
ctx.getFollowingUri(identifier)
ctx.getObjectUri(Note, { id: "123" })
ctx.getCollectionUri("bookmarks", { identifier: "alice" })
```

### Remote Lookups

```typescript
// Look up by handle or URI
const actor = await ctx.lookupObject("@user@remote.example");
const object = await ctx.lookupObject("https://remote.example/posts/123");

// WebFinger lookup
const webfinger = await ctx.lookupWebFinger("user@remote.example");

// Traverse remote collection
for await (const item of ctx.traverseCollection(collection)) {
  // Process each item
}
```

### Authentication

```typescript
// Get authenticated document loader
const loader = await ctx.getDocumentLoader({ identifier: "alice" });

// Get signed key owner from request
const owner = await ctx.getSignedKeyOwner();
```

---

## Testing

### Mock Federation (@fedify/testing)

```typescript
import { createFederation } from "@fedify/testing";

describe("Inbox handlers", () => {
  let federation: MockFederation;

  beforeEach(() => {
    federation = createFederation({ contextData: { db: mockDb } });
    federation.setInboxListeners("/users/{identifier}/inbox")
      .on(Follow, handleFollow);
  });

  afterEach(() => {
    federation.reset();
  });

  it("accepts follow requests", async () => {
    const follow = new Follow({
      actor: new URL("https://remote.example/users/bob"),
      object: new URL("https://example.com/users/alice"),
    });

    await federation.receiveActivity(follow);

    expect(federation.sentActivities).toHaveLength(1);
    expect(federation.sentActivities[0]).toBeInstanceOf(Accept);
  });
});
```

### CLI Tools

```bash
# Create ephemeral inbox server
fedify inbox

# Expose local server with HTTPS
fedify tunnel 3000

# Query remote objects
fedify lookup https://mastodon.social/@user
fedify lookup @user@mastodon.social

# Test WebFinger
fedify webfinger user@example.com

# View instance info
fedify nodeinfo mastodon.social
```

### Testing Tools

- **ActivityPub.Academy**: Mastodon instance that shows sent/received activities
- **BrowserPub**: Web tool to inspect ActivityPub objects

---

## Logging & Observability

### LogTape Configuration

```typescript
import { configure, getConsoleSink, getFileSink } from "@logtape/logtape";

await configure({
  sinks: {
    console: getConsoleSink(),
    file: getFileSink("fedify.log"),
  },
  filters: {},
  loggers: [
    {
      category: ["fedify"],
      sinks: ["console", "file"],
      lowestLevel: "debug",
    },
    {
      category: ["fedify", "federation", "inbox"],
      sinks: ["file"],
      lowestLevel: "debug",
    },
  ],
});
```

### Log Categories

| Category | Description |
|----------|-------------|
| `["fedify"]` | All Fedify logs |
| `["fedify", "federation", "http"]` | HTTP requests |
| `["fedify", "federation", "inbox"]` | Incoming activities |
| `["fedify", "federation", "outbox"]` | Outgoing activities |
| `["fedify", "sig", "http"]` | HTTP signatures |
| `["fedify", "sig", "ld"]` | Linked Data signatures |
| `["fedify", "webfinger"]` | WebFinger lookups |

### OpenTelemetry Integration

```typescript
import { getOpenTelemetrySink } from "@logtape/otel";

await configure({
  sinks: {
    otel: getOpenTelemetrySink(),
  },
  loggers: [
    { category: ["fedify"], sinks: ["otel"], lowestLevel: "info" },
  ],
});
```

---

## Framework Integration

### Hono

```typescript
import { Hono } from "hono";
import { federation } from "@fedify/hono";

const app = new Hono();
app.use(federation(fed, (c) => ({ db: c.env.DB })));
```

### Express

```typescript
import express from "express";
import { integrateFederation } from "@fedify/express";

const app = express();
app.set("trust proxy", true);
app.use(integrateFederation(fed, (req) => ({ db })));
```

### Next.js

```typescript
// middleware.ts
import { fedifyWith } from "@fedify/next";
import { federation } from "./federation";

export default fedifyWith(federation, () => ({}));

export const config = {
  matcher: ["/((?!_next|static).*)"],
};
```

### Custom Integration

```typescript
app.all("*", async (req) => {
  return await federation.fetch(req, {
    contextData: { db },
    onNotFound: async () => {
      // Handle non-federation requests
      return new Response("Not Found", { status: 404 });
    },
    onNotAcceptable: async () => {
      // Content negotiation fallback
      return new Response("HTML version", {
        headers: { "Content-Type": "text/html" },
      });
    },
  });
});
```

---

## Production Deployment

### Checklist

1. **Storage**
   - Use production KV store (Redis/PostgreSQL)
   - Use persistent message queue
   - Configure connection pooling

2. **Keys**
   - Generate keys during user registration
   - Store securely in database
   - Never regenerate on restart

3. **Scaling**
   - Separate web and queue workers
   - Use `manuallyStartQueue: true`
   - Monitor queue depth

4. **Security**
   - Set explicit `origin` option
   - Disable `allowPrivateAddress`
   - Implement rate limiting
   - Validate incoming activities

5. **Observability**
   - Configure logging sinks
   - Set up OpenTelemetry
   - Monitor delivery success rates

### Worker Separation

```typescript
// Web server
const federation = createFederation({
  kv: redisKv,
  queue: redisQueue,
  manuallyStartQueue: true,  // Don't start queue
});

// Queue worker (separate process)
const federation = createFederation({
  kv: redisKv,
  queue: redisQueue,
});
await federation.startQueue();
```

---

## FEP Reference

### Important FEPs

| FEP | Title | Relevance |
|-----|-------|-----------|
| FEP-8b32 | Object Integrity Proofs | Ed25519 signatures |
| FEP-fe34 | Origin-based security | Same-origin policy |
| FEP-1b12 | Group federation | Group interoperability |
| FEP-2c59 | Webfinger discovery | Actor discovery |
| FEP-e232 | Object links | Linking objects |

### Looking Up FEPs

```
https://codeberg.org/fediverse/fep/src/branch/main/fep/{id}/fep-{id}.md
```

Example: FEP-8b32 â†’ `https://codeberg.org/fediverse/fep/src/branch/main/fep/8b32/fep-8b32.md`

### FEP Resources

- Repository: https://codeberg.org/fediverse/fep
- Discussion: https://socialhub.activitypub.rocks/c/standards/fep/54
- Index: https://fep.swf.pub/
